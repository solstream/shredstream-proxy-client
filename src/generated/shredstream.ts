/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter eslint_disable,generate_dependencies
// @generated from protobuf file "shredstream.proto" (package "shredstream", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "./google/protobuf/timestamp";
import { Socket } from "./shared";
/**
 * @generated from protobuf message shredstream.Heartbeat
 */
export interface Heartbeat {
    /**
     * don't trust IP:PORT from tcp header since it can be tampered over the wire
     * `socket.ip` must match incoming packet's ip. this prevents spamming an unwitting destination
     *
     * @generated from protobuf field: shared.Socket socket = 1
     */
    socket?: Socket;
    /**
     * regions for shredstream proxy to receive shreds from
     * list of valid regions: https://docs.jito.wtf/lowlatencytxnsend/#api
     *
     * @generated from protobuf field: repeated string regions = 2
     */
    regions: string[];
}
/**
 * @generated from protobuf message shredstream.HeartbeatResponse
 */
export interface HeartbeatResponse {
    /**
     * client must respond within `ttl_ms` to keep stream alive
     *
     * @generated from protobuf field: uint32 ttl_ms = 1
     */
    ttlMs: number;
}
/**
 * @generated from protobuf message shredstream.TraceShred
 */
export interface TraceShred {
    /**
     * source region, one of: https://docs.jito.wtf/lowlatencytxnsend/#api
     *
     * @generated from protobuf field: string region = 1
     */
    region: string;
    /**
     * timestamp of creation
     *
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 2
     */
    createdAt?: Timestamp;
    /**
     * monotonically increases, resets upon service restart
     *
     * @generated from protobuf field: uint32 seq_num = 3
     */
    seqNum: number;
}
/**
 * @generated from protobuf message shredstream.SubscribeEntriesRequest
 */
export interface SubscribeEntriesRequest {
    /**
     * @generated from protobuf field: map<string, shredstream.SubscribeRequestFilterAccounts> accounts = 1
     */
    accounts: {
        [key: string]: SubscribeRequestFilterAccounts;
    };
    /**
     * @generated from protobuf field: map<string, shredstream.SubscribeRequestFilterTransactions> transactions = 3
     */
    transactions: {
        [key: string]: SubscribeRequestFilterTransactions;
    };
    /**
     * @generated from protobuf field: map<string, shredstream.SubscribeRequestFilterSlots> slots = 2
     */
    slots: {
        [key: string]: SubscribeRequestFilterSlots;
    };
    /**
     * @generated from protobuf field: optional shredstream.CommitmentLevel commitment = 6
     */
    commitment?: CommitmentLevel;
}
/**
 * @generated from protobuf message shredstream.SubscribeRequestFilterAccounts
 */
export interface SubscribeRequestFilterAccounts {
    /**
     * @generated from protobuf field: repeated string account = 2
     */
    account: string[];
    /**
     * @generated from protobuf field: repeated string owner = 3
     */
    owner: string[];
    /**
     * @generated from protobuf field: repeated shredstream.SubscribeRequestFilterAccountsFilter filters = 4
     */
    filters: SubscribeRequestFilterAccountsFilter[];
    /**
     * @generated from protobuf field: optional bool nonempty_txn_signature = 5
     */
    nonemptyTxnSignature?: boolean;
}
/**
 * @generated from protobuf message shredstream.SubscribeRequestFilterAccountsFilter
 */
export interface SubscribeRequestFilterAccountsFilter {
    /**
     * @generated from protobuf oneof: filter
     */
    filter: {
        oneofKind: "memcmp";
        /**
         * @generated from protobuf field: shredstream.SubscribeRequestFilterAccountsFilterMemcmp memcmp = 1
         */
        memcmp: SubscribeRequestFilterAccountsFilterMemcmp;
    } | {
        oneofKind: "datasize";
        /**
         * @generated from protobuf field: uint64 datasize = 2
         */
        datasize: bigint;
    } | {
        oneofKind: "tokenAccountState";
        /**
         * @generated from protobuf field: bool token_account_state = 3
         */
        tokenAccountState: boolean;
    } | {
        oneofKind: "lamports";
        /**
         * @generated from protobuf field: shredstream.SubscribeRequestFilterAccountsFilterLamports lamports = 4
         */
        lamports: SubscribeRequestFilterAccountsFilterLamports;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message shredstream.SubscribeRequestFilterAccountsFilterMemcmp
 */
export interface SubscribeRequestFilterAccountsFilterMemcmp {
    /**
     * @generated from protobuf field: uint64 offset = 1
     */
    offset: bigint;
    /**
     * @generated from protobuf oneof: data
     */
    data: {
        oneofKind: "bytes";
        /**
         * @generated from protobuf field: bytes bytes = 2
         */
        bytes: Uint8Array;
    } | {
        oneofKind: "base58";
        /**
         * @generated from protobuf field: string base58 = 3
         */
        base58: string;
    } | {
        oneofKind: "base64";
        /**
         * @generated from protobuf field: string base64 = 4
         */
        base64: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message shredstream.SubscribeRequestFilterAccountsFilterLamports
 */
export interface SubscribeRequestFilterAccountsFilterLamports {
    /**
     * @generated from protobuf oneof: cmp
     */
    cmp: {
        oneofKind: "eq";
        /**
         * @generated from protobuf field: uint64 eq = 1
         */
        eq: bigint;
    } | {
        oneofKind: "ne";
        /**
         * @generated from protobuf field: uint64 ne = 2
         */
        ne: bigint;
    } | {
        oneofKind: "lt";
        /**
         * @generated from protobuf field: uint64 lt = 3
         */
        lt: bigint;
    } | {
        oneofKind: "gt";
        /**
         * @generated from protobuf field: uint64 gt = 4
         */
        gt: bigint;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message shredstream.SubscribeRequestFilterSlots
 */
export interface SubscribeRequestFilterSlots {
    /**
     * @generated from protobuf field: optional bool filter_by_commitment = 1
     */
    filterByCommitment?: boolean;
    /**
     * @generated from protobuf field: optional bool interslot_updates = 2
     */
    interslotUpdates?: boolean;
}
/**
 * @generated from protobuf message shredstream.SubscribeRequestFilterTransactions
 */
export interface SubscribeRequestFilterTransactions {
    /**
     * @generated from protobuf field: repeated string account_include = 3
     */
    accountInclude: string[];
    /**
     * @generated from protobuf field: repeated string account_exclude = 4
     */
    accountExclude: string[];
    /**
     * @generated from protobuf field: repeated string account_required = 6
     */
    accountRequired: string[];
}
/**
 * @generated from protobuf message shredstream.Entry
 */
export interface Entry {
    /**
     * the slot that the entry is from
     *
     * @generated from protobuf field: uint64 slot = 1
     */
    slot: bigint;
    /**
     * Serialized bytes of Vec<Entry>: https://docs.rs/solana-entry/latest/solana_entry/entry/struct.Entry.html
     *
     * @generated from protobuf field: bytes entries = 2
     */
    entries: Uint8Array;
}
/**
 * @generated from protobuf enum shredstream.CommitmentLevel
 */
export enum CommitmentLevel {
    /**
     * @generated from protobuf enum value: PROCESSED = 0;
     */
    PROCESSED = 0,
    /**
     * @generated from protobuf enum value: CONFIRMED = 1;
     */
    CONFIRMED = 1,
    /**
     * @generated from protobuf enum value: FINALIZED = 2;
     */
    FINALIZED = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Heartbeat$Type extends MessageType<Heartbeat> {
    constructor() {
        super("shredstream.Heartbeat", [
            { no: 1, name: "socket", kind: "message", T: () => Socket },
            { no: 2, name: "regions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Heartbeat>): Heartbeat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.regions = [];
        if (value !== undefined)
            reflectionMergePartial<Heartbeat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Heartbeat): Heartbeat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* shared.Socket socket */ 1:
                    message.socket = Socket.internalBinaryRead(reader, reader.uint32(), options, message.socket);
                    break;
                case /* repeated string regions */ 2:
                    message.regions.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Heartbeat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* shared.Socket socket = 1; */
        if (message.socket)
            Socket.internalBinaryWrite(message.socket, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string regions = 2; */
        for (let i = 0; i < message.regions.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.regions[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message shredstream.Heartbeat
 */
export const Heartbeat = new Heartbeat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeartbeatResponse$Type extends MessageType<HeartbeatResponse> {
    constructor() {
        super("shredstream.HeartbeatResponse", [
            { no: 1, name: "ttl_ms", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeartbeatResponse>): HeartbeatResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ttlMs = 0;
        if (value !== undefined)
            reflectionMergePartial<HeartbeatResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeartbeatResponse): HeartbeatResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 ttl_ms */ 1:
                    message.ttlMs = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeartbeatResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 ttl_ms = 1; */
        if (message.ttlMs !== 0)
            writer.tag(1, WireType.Varint).uint32(message.ttlMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message shredstream.HeartbeatResponse
 */
export const HeartbeatResponse = new HeartbeatResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TraceShred$Type extends MessageType<TraceShred> {
    constructor() {
        super("shredstream.TraceShred", [
            { no: 1, name: "region", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 3, name: "seq_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TraceShred>): TraceShred {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.region = "";
        message.seqNum = 0;
        if (value !== undefined)
            reflectionMergePartial<TraceShred>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TraceShred): TraceShred {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string region */ 1:
                    message.region = reader.string();
                    break;
                case /* google.protobuf.Timestamp created_at */ 2:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* uint32 seq_num */ 3:
                    message.seqNum = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TraceShred, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string region = 1; */
        if (message.region !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.region);
        /* google.protobuf.Timestamp created_at = 2; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 seq_num = 3; */
        if (message.seqNum !== 0)
            writer.tag(3, WireType.Varint).uint32(message.seqNum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message shredstream.TraceShred
 */
export const TraceShred = new TraceShred$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeEntriesRequest$Type extends MessageType<SubscribeEntriesRequest> {
    constructor() {
        super("shredstream.SubscribeEntriesRequest", [
            { no: 1, name: "accounts", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => SubscribeRequestFilterAccounts } },
            { no: 3, name: "transactions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => SubscribeRequestFilterTransactions } },
            { no: 2, name: "slots", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => SubscribeRequestFilterSlots } },
            { no: 6, name: "commitment", kind: "enum", opt: true, T: () => ["shredstream.CommitmentLevel", CommitmentLevel] }
        ]);
    }
    create(value?: PartialMessage<SubscribeEntriesRequest>): SubscribeEntriesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accounts = {};
        message.transactions = {};
        message.slots = {};
        if (value !== undefined)
            reflectionMergePartial<SubscribeEntriesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEntriesRequest): SubscribeEntriesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, shredstream.SubscribeRequestFilterAccounts> accounts */ 1:
                    this.binaryReadMap1(message.accounts, reader, options);
                    break;
                case /* map<string, shredstream.SubscribeRequestFilterTransactions> transactions */ 3:
                    this.binaryReadMap3(message.transactions, reader, options);
                    break;
                case /* map<string, shredstream.SubscribeRequestFilterSlots> slots */ 2:
                    this.binaryReadMap2(message.slots, reader, options);
                    break;
                case /* optional shredstream.CommitmentLevel commitment */ 6:
                    message.commitment = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: SubscribeEntriesRequest["accounts"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SubscribeEntriesRequest["accounts"] | undefined, val: SubscribeEntriesRequest["accounts"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = SubscribeRequestFilterAccounts.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for shredstream.SubscribeEntriesRequest.accounts");
            }
        }
        map[key ?? ""] = val ?? SubscribeRequestFilterAccounts.create();
    }
    private binaryReadMap3(map: SubscribeEntriesRequest["transactions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SubscribeEntriesRequest["transactions"] | undefined, val: SubscribeEntriesRequest["transactions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = SubscribeRequestFilterTransactions.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for shredstream.SubscribeEntriesRequest.transactions");
            }
        }
        map[key ?? ""] = val ?? SubscribeRequestFilterTransactions.create();
    }
    private binaryReadMap2(map: SubscribeEntriesRequest["slots"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SubscribeEntriesRequest["slots"] | undefined, val: SubscribeEntriesRequest["slots"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = SubscribeRequestFilterSlots.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for shredstream.SubscribeEntriesRequest.slots");
            }
        }
        map[key ?? ""] = val ?? SubscribeRequestFilterSlots.create();
    }
    internalBinaryWrite(message: SubscribeEntriesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, shredstream.SubscribeRequestFilterAccounts> accounts = 1; */
        for (let k of globalThis.Object.keys(message.accounts)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            SubscribeRequestFilterAccounts.internalBinaryWrite(message.accounts[k], writer, options);
            writer.join().join();
        }
        /* map<string, shredstream.SubscribeRequestFilterSlots> slots = 2; */
        for (let k of globalThis.Object.keys(message.slots)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            SubscribeRequestFilterSlots.internalBinaryWrite(message.slots[k], writer, options);
            writer.join().join();
        }
        /* map<string, shredstream.SubscribeRequestFilterTransactions> transactions = 3; */
        for (let k of globalThis.Object.keys(message.transactions)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            SubscribeRequestFilterTransactions.internalBinaryWrite(message.transactions[k], writer, options);
            writer.join().join();
        }
        /* optional shredstream.CommitmentLevel commitment = 6; */
        if (message.commitment !== undefined)
            writer.tag(6, WireType.Varint).int32(message.commitment);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message shredstream.SubscribeEntriesRequest
 */
export const SubscribeEntriesRequest = new SubscribeEntriesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeRequestFilterAccounts$Type extends MessageType<SubscribeRequestFilterAccounts> {
    constructor() {
        super("shredstream.SubscribeRequestFilterAccounts", [
            { no: 2, name: "account", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "owner", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "filters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubscribeRequestFilterAccountsFilter },
            { no: 5, name: "nonempty_txn_signature", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeRequestFilterAccounts>): SubscribeRequestFilterAccounts {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = [];
        message.owner = [];
        message.filters = [];
        if (value !== undefined)
            reflectionMergePartial<SubscribeRequestFilterAccounts>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeRequestFilterAccounts): SubscribeRequestFilterAccounts {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string account */ 2:
                    message.account.push(reader.string());
                    break;
                case /* repeated string owner */ 3:
                    message.owner.push(reader.string());
                    break;
                case /* repeated shredstream.SubscribeRequestFilterAccountsFilter filters */ 4:
                    message.filters.push(SubscribeRequestFilterAccountsFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool nonempty_txn_signature */ 5:
                    message.nonemptyTxnSignature = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeRequestFilterAccounts, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string account = 2; */
        for (let i = 0; i < message.account.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.account[i]);
        /* repeated string owner = 3; */
        for (let i = 0; i < message.owner.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.owner[i]);
        /* repeated shredstream.SubscribeRequestFilterAccountsFilter filters = 4; */
        for (let i = 0; i < message.filters.length; i++)
            SubscribeRequestFilterAccountsFilter.internalBinaryWrite(message.filters[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional bool nonempty_txn_signature = 5; */
        if (message.nonemptyTxnSignature !== undefined)
            writer.tag(5, WireType.Varint).bool(message.nonemptyTxnSignature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message shredstream.SubscribeRequestFilterAccounts
 */
export const SubscribeRequestFilterAccounts = new SubscribeRequestFilterAccounts$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeRequestFilterAccountsFilter$Type extends MessageType<SubscribeRequestFilterAccountsFilter> {
    constructor() {
        super("shredstream.SubscribeRequestFilterAccountsFilter", [
            { no: 1, name: "memcmp", kind: "message", oneof: "filter", T: () => SubscribeRequestFilterAccountsFilterMemcmp },
            { no: 2, name: "datasize", kind: "scalar", oneof: "filter", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "token_account_state", kind: "scalar", oneof: "filter", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "lamports", kind: "message", oneof: "filter", T: () => SubscribeRequestFilterAccountsFilterLamports }
        ]);
    }
    create(value?: PartialMessage<SubscribeRequestFilterAccountsFilter>): SubscribeRequestFilterAccountsFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filter = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SubscribeRequestFilterAccountsFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeRequestFilterAccountsFilter): SubscribeRequestFilterAccountsFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* shredstream.SubscribeRequestFilterAccountsFilterMemcmp memcmp */ 1:
                    message.filter = {
                        oneofKind: "memcmp",
                        memcmp: SubscribeRequestFilterAccountsFilterMemcmp.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).memcmp)
                    };
                    break;
                case /* uint64 datasize */ 2:
                    message.filter = {
                        oneofKind: "datasize",
                        datasize: reader.uint64().toBigInt()
                    };
                    break;
                case /* bool token_account_state */ 3:
                    message.filter = {
                        oneofKind: "tokenAccountState",
                        tokenAccountState: reader.bool()
                    };
                    break;
                case /* shredstream.SubscribeRequestFilterAccountsFilterLamports lamports */ 4:
                    message.filter = {
                        oneofKind: "lamports",
                        lamports: SubscribeRequestFilterAccountsFilterLamports.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).lamports)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeRequestFilterAccountsFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* shredstream.SubscribeRequestFilterAccountsFilterMemcmp memcmp = 1; */
        if (message.filter.oneofKind === "memcmp")
            SubscribeRequestFilterAccountsFilterMemcmp.internalBinaryWrite(message.filter.memcmp, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 datasize = 2; */
        if (message.filter.oneofKind === "datasize")
            writer.tag(2, WireType.Varint).uint64(message.filter.datasize);
        /* bool token_account_state = 3; */
        if (message.filter.oneofKind === "tokenAccountState")
            writer.tag(3, WireType.Varint).bool(message.filter.tokenAccountState);
        /* shredstream.SubscribeRequestFilterAccountsFilterLamports lamports = 4; */
        if (message.filter.oneofKind === "lamports")
            SubscribeRequestFilterAccountsFilterLamports.internalBinaryWrite(message.filter.lamports, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message shredstream.SubscribeRequestFilterAccountsFilter
 */
export const SubscribeRequestFilterAccountsFilter = new SubscribeRequestFilterAccountsFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeRequestFilterAccountsFilterMemcmp$Type extends MessageType<SubscribeRequestFilterAccountsFilterMemcmp> {
    constructor() {
        super("shredstream.SubscribeRequestFilterAccountsFilterMemcmp", [
            { no: 1, name: "offset", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "bytes", kind: "scalar", oneof: "data", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "base58", kind: "scalar", oneof: "data", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "base64", kind: "scalar", oneof: "data", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeRequestFilterAccountsFilterMemcmp>): SubscribeRequestFilterAccountsFilterMemcmp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.offset = 0n;
        message.data = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SubscribeRequestFilterAccountsFilterMemcmp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeRequestFilterAccountsFilterMemcmp): SubscribeRequestFilterAccountsFilterMemcmp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 offset */ 1:
                    message.offset = reader.uint64().toBigInt();
                    break;
                case /* bytes bytes */ 2:
                    message.data = {
                        oneofKind: "bytes",
                        bytes: reader.bytes()
                    };
                    break;
                case /* string base58 */ 3:
                    message.data = {
                        oneofKind: "base58",
                        base58: reader.string()
                    };
                    break;
                case /* string base64 */ 4:
                    message.data = {
                        oneofKind: "base64",
                        base64: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeRequestFilterAccountsFilterMemcmp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 offset = 1; */
        if (message.offset !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.offset);
        /* bytes bytes = 2; */
        if (message.data.oneofKind === "bytes")
            writer.tag(2, WireType.LengthDelimited).bytes(message.data.bytes);
        /* string base58 = 3; */
        if (message.data.oneofKind === "base58")
            writer.tag(3, WireType.LengthDelimited).string(message.data.base58);
        /* string base64 = 4; */
        if (message.data.oneofKind === "base64")
            writer.tag(4, WireType.LengthDelimited).string(message.data.base64);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message shredstream.SubscribeRequestFilterAccountsFilterMemcmp
 */
export const SubscribeRequestFilterAccountsFilterMemcmp = new SubscribeRequestFilterAccountsFilterMemcmp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeRequestFilterAccountsFilterLamports$Type extends MessageType<SubscribeRequestFilterAccountsFilterLamports> {
    constructor() {
        super("shredstream.SubscribeRequestFilterAccountsFilterLamports", [
            { no: 1, name: "eq", kind: "scalar", oneof: "cmp", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "ne", kind: "scalar", oneof: "cmp", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "lt", kind: "scalar", oneof: "cmp", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "gt", kind: "scalar", oneof: "cmp", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeRequestFilterAccountsFilterLamports>): SubscribeRequestFilterAccountsFilterLamports {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cmp = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SubscribeRequestFilterAccountsFilterLamports>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeRequestFilterAccountsFilterLamports): SubscribeRequestFilterAccountsFilterLamports {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 eq */ 1:
                    message.cmp = {
                        oneofKind: "eq",
                        eq: reader.uint64().toBigInt()
                    };
                    break;
                case /* uint64 ne */ 2:
                    message.cmp = {
                        oneofKind: "ne",
                        ne: reader.uint64().toBigInt()
                    };
                    break;
                case /* uint64 lt */ 3:
                    message.cmp = {
                        oneofKind: "lt",
                        lt: reader.uint64().toBigInt()
                    };
                    break;
                case /* uint64 gt */ 4:
                    message.cmp = {
                        oneofKind: "gt",
                        gt: reader.uint64().toBigInt()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeRequestFilterAccountsFilterLamports, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 eq = 1; */
        if (message.cmp.oneofKind === "eq")
            writer.tag(1, WireType.Varint).uint64(message.cmp.eq);
        /* uint64 ne = 2; */
        if (message.cmp.oneofKind === "ne")
            writer.tag(2, WireType.Varint).uint64(message.cmp.ne);
        /* uint64 lt = 3; */
        if (message.cmp.oneofKind === "lt")
            writer.tag(3, WireType.Varint).uint64(message.cmp.lt);
        /* uint64 gt = 4; */
        if (message.cmp.oneofKind === "gt")
            writer.tag(4, WireType.Varint).uint64(message.cmp.gt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message shredstream.SubscribeRequestFilterAccountsFilterLamports
 */
export const SubscribeRequestFilterAccountsFilterLamports = new SubscribeRequestFilterAccountsFilterLamports$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeRequestFilterSlots$Type extends MessageType<SubscribeRequestFilterSlots> {
    constructor() {
        super("shredstream.SubscribeRequestFilterSlots", [
            { no: 1, name: "filter_by_commitment", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "interslot_updates", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeRequestFilterSlots>): SubscribeRequestFilterSlots {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeRequestFilterSlots>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeRequestFilterSlots): SubscribeRequestFilterSlots {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool filter_by_commitment */ 1:
                    message.filterByCommitment = reader.bool();
                    break;
                case /* optional bool interslot_updates */ 2:
                    message.interslotUpdates = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeRequestFilterSlots, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool filter_by_commitment = 1; */
        if (message.filterByCommitment !== undefined)
            writer.tag(1, WireType.Varint).bool(message.filterByCommitment);
        /* optional bool interslot_updates = 2; */
        if (message.interslotUpdates !== undefined)
            writer.tag(2, WireType.Varint).bool(message.interslotUpdates);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message shredstream.SubscribeRequestFilterSlots
 */
export const SubscribeRequestFilterSlots = new SubscribeRequestFilterSlots$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeRequestFilterTransactions$Type extends MessageType<SubscribeRequestFilterTransactions> {
    constructor() {
        super("shredstream.SubscribeRequestFilterTransactions", [
            { no: 3, name: "account_include", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "account_exclude", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "account_required", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeRequestFilterTransactions>): SubscribeRequestFilterTransactions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountInclude = [];
        message.accountExclude = [];
        message.accountRequired = [];
        if (value !== undefined)
            reflectionMergePartial<SubscribeRequestFilterTransactions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeRequestFilterTransactions): SubscribeRequestFilterTransactions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string account_include */ 3:
                    message.accountInclude.push(reader.string());
                    break;
                case /* repeated string account_exclude */ 4:
                    message.accountExclude.push(reader.string());
                    break;
                case /* repeated string account_required */ 6:
                    message.accountRequired.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeRequestFilterTransactions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string account_include = 3; */
        for (let i = 0; i < message.accountInclude.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.accountInclude[i]);
        /* repeated string account_exclude = 4; */
        for (let i = 0; i < message.accountExclude.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.accountExclude[i]);
        /* repeated string account_required = 6; */
        for (let i = 0; i < message.accountRequired.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.accountRequired[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message shredstream.SubscribeRequestFilterTransactions
 */
export const SubscribeRequestFilterTransactions = new SubscribeRequestFilterTransactions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Entry$Type extends MessageType<Entry> {
    constructor() {
        super("shredstream.Entry", [
            { no: 1, name: "slot", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "entries", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Entry>): Entry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.slot = 0n;
        message.entries = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Entry): Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 slot */ 1:
                    message.slot = reader.uint64().toBigInt();
                    break;
                case /* bytes entries */ 2:
                    message.entries = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 slot = 1; */
        if (message.slot !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.slot);
        /* bytes entries = 2; */
        if (message.entries.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.entries);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message shredstream.Entry
 */
export const Entry = new Entry$Type();
/**
 * @generated ServiceType for protobuf service shredstream.Shredstream
 */
export const Shredstream = new ServiceType("shredstream.Shredstream", [
    { name: "SendHeartbeat", options: {}, I: Heartbeat, O: HeartbeatResponse }
]);
/**
 * @generated ServiceType for protobuf service shredstream.ShredstreamProxy
 */
export const ShredstreamProxy = new ServiceType("shredstream.ShredstreamProxy", [
    { name: "SubscribeEntries", serverStreaming: true, options: {}, I: SubscribeEntriesRequest, O: Entry }
]);
